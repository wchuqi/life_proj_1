# 回溯算法

## 总结

> 回溯算法在一棵树上做深度优先遍历，遍历的实现方式是递归

**回溯算法**和**深度优先遍历**是一回事

理解**回溯**
> 从深层节点回到浅层节点必须【回到过去】

回溯：状态重置+撤销选择+回到过去+恢复现场

技巧
- 先画出递归树（一棵决策树）
- 善用剪枝
- 穷举式的搜索算法，走不通就回退

## 模板
```java
res = []    # 存放所欲符合条件结果的集合
path = []   # 存放当前符合条件的结果
def backtracking(nums):             # nums 为选择元素列表
    if 遇到边界条件:                  # 说明找到了一组符合条件的结果
        res.append(path[:])         # 将当前符合条件的结果放入集合中
        return

    for i in range(len(nums)):      # 枚举可选元素列表
        path.append(nums[i])        # 选择元素
        backtracking(nums)          # 递归搜索
        path.pop()                  # 撤销选择

backtracking(nums)
```

# 题目

## 子集
参考：
https://www.cnblogs.com/labuladong/p/15953806.html

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>(); 
    public List<List<Integer>> subsets(int[] nums) {
        backtrace(nums, 0);
        return result;
    }
    
    private void backtrace(int[] nums, int startIndex) {
        result.add(new ArrayList<>(path));
        for (int i=startIndex;i<nums.length;i++) {
            path.add(nums[i]);
            backtrace(nums, i+1);
            path.removeLast();
        }
    }
}
```

## N皇后

```java
class Solution {
    List<List<String>> result = new ArrayList<>();
    /* 输入棋盘边长 n，返回所有合法的放置 */
    public List<List<String>> solveNQueens(int n) {
        // '.' 表示空，'Q' 表示皇后，初始化空棋盘
        List<String> board = new ArrayList<>();
        for (int i=0;i<n;i++) {
            StringBuilder builder = new StringBuilder();
            for (int j=0;j<n;j++) {
                builder.append('.');
            }
            board.add(builder.toString());
        }
        backtrace(board, 0);
        return result;
    }

    // 路径：board 中小于 row 的那些行都已经成功放置了皇后
    // 选择列表：第 row 行的所有列都是放置皇后的选择
    // 结束条件：row 超过 board 的最后一行
    private void backtrace(List<String> board, int row) {
        // 触发结束条件
        if (row == board.size()) {
            result.add(new ArrayList<>(board));
            return;
        }
        int n = board.get(row).length();
        for (int col=0;col<n;col++) {
            // 排除不合法选择
            if (!isValid(board, row, col)) {
                continue;
            }
            // 做选择
            StringBuilder builder = new StringBuilder(board.get(row));
            builder.setCharAt(col, 'Q');
            board.set(row, builder.toString());
            // 进入下一行决策
            backtrace(board, row+1);
            // 撤销选择
            builder.setCharAt(col, '.');
            board.set(row, builder.toString());
        }
    }


    /* 是否可以在 board[row][col] 放置皇后？ */
    /* 路径：board 中小于 row 的那些行都已经成功放置了皇后 */
    private boolean isValid(List<String> board, int row, int col) {
        int n = board.size();
        /* 检查列是否有皇后互相冲突 */
        for (int i=0;i<n;i++) {
            if (board.get(i).charAt(col) == 'Q') {
                return false;
            }
        }
        /* 检查右上方是否有皇后互相冲突 */
        for (int i=row-1,j=col+1;i>=0 && j < n;i--,j++) {
            if (board.get(i).charAt(j) == 'Q') {
                return false;
            }
        }
        /* 检查左上方是否有皇后互相冲突 */
        for (int i=row-1,j=col-1;i>=0 && j >=0;i--,j--) {
            if (board.get(i).charAt(j) == 'Q') {
                return false;
            }
        }
        return true;
    }
}
```

## 全排列
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

```java
import java.util.LinkedList;
import java.util.List;

class Solution {
    List<List<Integer>> result = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        LinkedList<Integer> paths = new LinkedList<>();
        boolean[] visited = new boolean[nums.length];
        backtrace(nums, paths, visited);
        return result;
    }

    private void backtrace(int[] nums, LinkedList<Integer> paths, boolean[] visited) {
        if (paths.size() == nums.length) {
            result.add(new LinkedList<>(paths));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (visited[i]) {
                continue;
            }
            paths.add(nums[i]);
            visited[i] = true;
            backtrace(nums, paths, visited);
            paths.removeLast();
            visited[i] = false;
        }
    }
}
```

## 全排列II

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        LinkedList<Integer> path = new LinkedList<>();
        Arrays.sort(nums);
        backtrace(nums, path, used);
        return result;
    }
    
    private void backtrace(int[] nums, LinkedList<Integer> path, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i=0;i<nums.length;i++) {
            if (used[i]) {
                continue;
            }
			// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
            if (i > 0 && nums[i-1]==nums[i] && !used[i-1]) {
                // 如果前面的相邻相等元素没有用过，则跳过
                continue;
            }
            path.add(nums[i]);
            used[i]=true;
            backtrace(nums, path, used);
            path.removeLast();
            used[i]=false;
        }
    }
}   
```
