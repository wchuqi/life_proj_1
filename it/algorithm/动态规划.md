
# 题目

## 279.完全平方数
https://leetcode.cn/problems/perfect-squares/submissions/?envType=problem-list-v2&envId=6uaxYMyj

思路：
https://algo.itcharge.cn/solutions/0200-0299/perfect-squares/#%E6%80%9D%E8%B7%AF-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92

我们可以将这道题转换为「完全背包问题」中恰好装满背包的方案数问题。
1.	将 k=1,4,9,16,...看做是 k种物品，每种物品都可以无限次使用。
2.	将 n看做是背包的装载上限。
3.	这道题就变成了，从 k 种物品中选择一些物品，装入装载上限为 n的背包中，恰好装满背包最少需要多少件物品。
1. 划分阶段
按照当前背包的载重上限进行阶段划分。
2. 定义状态
定义状态 dp[w] 表示为：从完全平方数中挑选一些数，使其和恰好凑成 w，最少需要多少个完全平方数。
3. 状态转移方程
dp[w]=min{dp[w], dp[w−num]+1}
4. 初始条件
•	恰好凑成和为 0，最少需要 0 个完全平方数。
•	默认情况下，在不使用完全平方数时，都不能恰好凑成和为 w ，此时将状态值设置为一个极大值（比如 n+1），表示无法凑成。
5. 最终结果
根据我们之前定义的状态，dp[w]表示为：将物品装入装载上限为 w的背包中，恰好装满背包，最少需要多少件物品。 所以最终结果为 dp[n]。
1.	如果 dp[n]≠n+1，则说明：dp[n] 为装入装载上限为 n 的背包，恰好装满背包，最少需要的物品数量，则返回 dp[n]。
2.	如果 dp[n]=n+1，则说明：无法恰好装满背包，则返回 −1。因为 n 肯定能由 n 个 11 组成，所以这种情况并不会出现。

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            dp[i] = i;//最坏的情况都是由1的平方组成
            for (int j = 1; j * j <= i; j++) {
                //动态规划公式
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
}
```

## 连续最大和子数组

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然答案就是：
Max {f(i)} 0≤i≤n−1
因此，只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。
如何求 f(i) 呢？
可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i] 的大小，于是动态规划转移方程：
f(i)=max{f(i−1)+nums[i],nums[i]}

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int res = dp[0];
        for (int i=1;i<nums.length;i++) {
            dp[i] += Math.max(dp[i-1]+nums[i], nums[i]);
            res = Math.max(dp[i], res);
        }
        return res;
    }
}
```

